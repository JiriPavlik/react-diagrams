{"version":3,"file":"main.19765828d8ab7e6aedd7.bundle.js","sources":["webpack:///./demos/demo-simple-flow/index.tsx","webpack:///./demos/demo-locks/index.tsx","webpack:///./demos/demo-serializing/index.tsx","webpack:///./demos/demo-drag-and-drop/components/BodyWidget.tsx","webpack:///./demos/demo-drag-and-drop/components/TrayWidget.tsx","webpack:///./demos/demo-drag-and-drop/components/TrayItemWidget.tsx","webpack:///./demos/demo-custom-node1/DiamondNodeWidget.tsx","webpack:///./demos/helpers/DemoCanvasWidget.tsx","webpack:///../react-canvas-core/src/entities/layer/TransformLayerWidget.tsx","webpack:///../react-canvas-core/src/entities/selection/SelectionBoxWidget.tsx","webpack:///../react-diagrams-core/src/entities/node/NodeWidget.tsx","webpack:///../react-diagrams-defaults/src/label/DefaultLabelWidget.tsx","webpack:///../react-diagrams-defaults/src/link/DefaultLinkPointWidget.tsx","webpack:///../react-diagrams-defaults/src/node/DefaultNodeWidget.tsx","webpack:///../react-diagrams-defaults/src/port/DefaultPortLabelWidget.tsx","webpack:///../react-diagrams-defaults/src/node/NodeAttributes.tsx","webpack:///./demos/helpers/DemoWorkspaceWidget.tsx","webpack:///../react-canvas-core/src/entities/canvas/CanvasWidget.tsx","webpack:///../react-diagrams-core/src/entities/label/LabelWidget.tsx","webpack:///../react-diagrams-core/src/DiagramEngine.ts","webpack:///../react-diagrams-defaults/src/link/DefaultLinkFactory.tsx","webpack:///../react-diagrams-defaults/src/node/NodeContextMenu.tsx"],"sourcesContent":["import createEngine, { DiagramModel, DefaultNodeModel, DefaultDiagramState } from '@projectstorm/react-diagrams';\nimport * as React from 'react';\nimport { CanvasWidget } from '@projectstorm/react-canvas-core';\nimport { DemoCanvasWidget } from '../helpers/DemoCanvasWidget';\n\nexport default () => {\n\t//1) setup the diagram engine\n\tvar engine = createEngine();\n\n\t// ############################################ MAGIC HAPPENS HERE\n\tconst state = engine.getStateMachine().getCurrentState();\n\tif (state instanceof DefaultDiagramState) {\n\t\tstate.dragNewLink.config.allowLooseLinks = false;\n\t}\n\t// ############################################ MAGIC HAPPENS HERE\n\n\t//2) setup the diagram model\n\tvar model = new DiagramModel();\n\n\t//3-A) create a default node\n\tvar node1 = new DefaultNodeModel('Node 1', 'rgb(0,192,255)');\n\tvar port1 = node1.addOutPort('Out');\n\tnode1.setPosition(100, 100);\n\n\t//3-B) create another default node\n\tvar node2 = new DefaultNodeModel('Node 2', 'rgb(192,255,0)');\n\tvar port2 = node2.addInPort('In');\n\tnode2.setPosition(400, 100);\n\n\t//3-C) link the 2 nodes together\n\tvar link1 = port1.link(port2);\n\n\t//3-D) create an orphaned node\n\tvar node3 = new DefaultNodeModel('Node 3', 'rgb(0,192,255)');\n\tnode3.addOutPort('Out');\n\tnode3.setPosition(100, 200);\n\n\t//4) add the models to the root graph\n\tmodel.addAll(node1, node2, node3, link1);\n\n\t//5) load model into engine\n\tengine.setModel(model);\n\n\t//6) render the diagram!\n\treturn (\n\t\t<DemoCanvasWidget>\n\t\t\t<CanvasWidget engine={engine} />\n\t\t</DemoCanvasWidget>\n\t);\n};\n","import * as React from 'react';\nimport createEngine, { DiagramModel, DefaultNodeModel } from '@projectstorm/react-diagrams';\nimport { CanvasWidget } from '@projectstorm/react-canvas-core';\nimport { DemoCanvasWidget } from '../helpers/DemoCanvasWidget';\n\n/**\n *\n * Shows how you can lock down the system so that the entire scene cant be interacted with.\n *\n * @Author Dylan Vorster\n */\nexport default () => {\n\t//1) setup the diagram engine\n\tvar engine = createEngine();\n\n\tvar model = new DiagramModel();\n\n\t// sample for link with simple line (no additional points)\n\tvar node1 = new DefaultNodeModel('Node 1', 'rgb(0,192,255)');\n\tvar port1 = node1.addOutPort('Out');\n\tnode1.setPosition(100, 100);\n\n\tvar node2 = new DefaultNodeModel('Node 2', 'rgb(192,255,0)');\n\tvar port2 = node2.addInPort('In');\n\tnode2.setPosition(400, 100);\n\n\tlet link1 = port1.link(port2);\n\n\tmodel.addAll(node1, node2, link1);\n\n\t// sample for link with complex line (additional points)\n\tvar node3 = new DefaultNodeModel('Node 3', 'rgb(0,192,255)');\n\tvar port3 = node3.addOutPort('Out');\n\tnode3.setPosition(100, 250);\n\n\tvar node4 = new DefaultNodeModel('Node 4', 'rgb(192,255,0)');\n\tvar port4 = node4.addInPort('In');\n\tnode4.setPosition(400, 250);\n\n\tvar link2 = port3.link(port4);\n\n\tlink2.point(350, 225);\n\tlink2.point(200, 225);\n\n\tmodel.addAll(node3, node4, link2);\n\n\tengine.setModel(model);\n\n\t//!========================================= <<<<<<<\n\n\tmodel.setLocked(true);\n\n\t//!=========================================  <<<<<<<\n\n\treturn (\n\t\t<DemoCanvasWidget>\n\t\t\t<CanvasWidget engine={engine} />\n\t\t</DemoCanvasWidget>\n\t);\n};\n","import createEngine, { DiagramModel, DefaultNodeModel } from '@projectstorm/react-diagrams';\nimport * as React from 'react';\nimport { DemoButton, DemoWorkspaceWidget } from '../helpers/DemoWorkspaceWidget';\nimport { action } from '@storybook/addon-actions';\nimport * as beautify from 'json-beautify';\nimport { CanvasWidget } from '@projectstorm/react-canvas-core';\nimport { DemoCanvasWidget } from '../helpers/DemoCanvasWidget';\n\nexport default () => {\n\t//1) setup the diagram engine\n\tvar engine = createEngine();\n\n\t//2) setup the diagram model\n\tvar model = new DiagramModel();\n\n\t//3-A) create a default node\n\tvar node1 = new DefaultNodeModel('Node 1', 'rgb(0,192,255)');\n\tvar port1 = node1.addOutPort('Out');\n\tnode1.setPosition(100, 100);\n\n\t//3-B) create another default node\n\tvar node2 = new DefaultNodeModel('Node 2', 'rgb(192,255,0)');\n\tvar port2 = node2.addInPort('In');\n\tnode2.setPosition(400, 100);\n\n\t//3-C) link the 2 nodes together\n\tvar link1 = port1.link(port2);\n\n\t//4) add the models to the root graph\n\tmodel.addAll(node1, node2, link1);\n\n\t//5) load model into engine\n\tengine.setModel(model);\n\n\t//!------------- SERIALIZING ------------------\n\n\tvar str = JSON.stringify(model.serialize());\n\n\t//!------------- DESERIALIZING ----------------\n\n\tvar model2 = new DiagramModel();\n\tmodel2.deserializeModel(JSON.parse(str), engine);\n\tengine.setModel(model2);\n\n\treturn (\n\t\t<DemoWorkspaceWidget\n\t\t\tbuttons={\n\t\t\t\t<DemoButton\n\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\taction('Serialized Graph')(beautify(model2.serialize(), null, 2, 80));\n\t\t\t\t\t}}>\n\t\t\t\t\tSerialize Graph\n\t\t\t\t</DemoButton>\n\t\t\t}>\n\t\t\t<DemoCanvasWidget>\n\t\t\t\t<CanvasWidget engine={engine} />\n\t\t\t</DemoCanvasWidget>\n\t\t</DemoWorkspaceWidget>\n\t);\n};\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { TrayWidget } from './TrayWidget';\nimport { Application } from '../Application';\nimport { TrayItemWidget } from './TrayItemWidget';\nimport { DefaultNodeModel } from '@projectstorm/react-diagrams';\nimport { CanvasWidget } from '@projectstorm/react-canvas-core';\nimport { DemoCanvasWidget } from '../../helpers/DemoCanvasWidget';\nimport styled from '@emotion/styled';\n\nexport interface BodyWidgetProps {\n\tapp: Application;\n}\n\nnamespace S {\n\texport const Body = styled.div`\n\t\tflex-grow: 1;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\tmin-height: 100%;\n\t`;\n\n\texport const Header = styled.div`\n\t\tdisplay: flex;\n\t\tbackground: rgb(30, 30, 30);\n\t\tflex-grow: 0;\n\t\tflex-shrink: 0;\n\t\tcolor: white;\n\t\tfont-family: Helvetica, Arial, sans-serif;\n\t\tpadding: 10px;\n\t\talign-items: center;\n\t`;\n\n\texport const Content = styled.div`\n\t\tdisplay: flex;\n\t\tflex-grow: 1;\n\t`;\n\n\texport const Layer = styled.div`\n\t\tposition: relative;\n\t\tflex-grow: 1;\n\t`;\n}\n\nexport class BodyWidget extends React.Component<BodyWidgetProps> {\n\trender() {\n\t\treturn (\n\t\t\t<S.Body>\n\t\t\t\t<S.Header>\n\t\t\t\t\t<div className=\"title\">Storm React Diagrams - DnD demo</div>\n\t\t\t\t</S.Header>\n\t\t\t\t<S.Content>\n\t\t\t\t\t<TrayWidget>\n\t\t\t\t\t\t<TrayItemWidget model={{ type: 'in' }} name=\"In Node\" color=\"rgb(192,255,0)\" />\n\t\t\t\t\t\t<TrayItemWidget model={{ type: 'out' }} name=\"Out Node\" color=\"rgb(0,192,255)\" />\n\t\t\t\t\t</TrayWidget>\n\t\t\t\t\t<S.Layer\n\t\t\t\t\t\tonDrop={event => {\n\t\t\t\t\t\t\tvar data = JSON.parse(event.dataTransfer.getData('storm-diagram-node'));\n\t\t\t\t\t\t\tvar nodesCount = _.keys(\n\t\t\t\t\t\t\t\tthis.props.app\n\t\t\t\t\t\t\t\t\t.getDiagramEngine()\n\t\t\t\t\t\t\t\t\t.getModel()\n\t\t\t\t\t\t\t\t\t.getNodes()\n\t\t\t\t\t\t\t).length;\n\n\t\t\t\t\t\t\tvar node: DefaultNodeModel = null;\n\t\t\t\t\t\t\tif (data.type === 'in') {\n\t\t\t\t\t\t\t\tnode = new DefaultNodeModel('Node ' + (nodesCount + 1), 'rgb(192,255,0)');\n\t\t\t\t\t\t\t\tnode.addInPort('In');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnode = new DefaultNodeModel('Node ' + (nodesCount + 1), 'rgb(0,192,255)');\n\t\t\t\t\t\t\t\tnode.addOutPort('Out');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar point = this.props.app.getDiagramEngine().getRelativeMousePoint(event);\n\t\t\t\t\t\t\tnode.setPosition(point);\n\t\t\t\t\t\t\tthis.props.app\n\t\t\t\t\t\t\t\t.getDiagramEngine()\n\t\t\t\t\t\t\t\t.getModel()\n\t\t\t\t\t\t\t\t.addNode(node);\n\t\t\t\t\t\t\tthis.forceUpdate();\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tonDragOver={event => {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t<DemoCanvasWidget>\n\t\t\t\t\t\t\t<CanvasWidget engine={this.props.app.getDiagramEngine()} />\n\t\t\t\t\t\t</DemoCanvasWidget>\n\t\t\t\t\t</S.Layer>\n\t\t\t\t</S.Content>\n\t\t\t</S.Body>\n\t\t);\n\t}\n}\n","import * as React from 'react';\nimport styled from '@emotion/styled';\n\nnamespace S {\n\texport const Tray = styled.div`\n\t\tmin-width: 200px;\n\t\tbackground: rgb(20, 20, 20);\n\t\tflex-grow: 0;\n\t\tflex-shrink: 0;\n\t`;\n}\n\nexport class TrayWidget extends React.Component {\n\trender() {\n\t\treturn <S.Tray>{this.props.children}</S.Tray>;\n\t}\n}\n","import * as React from 'react';\nimport styled from '@emotion/styled';\n\nexport interface TrayItemWidgetProps {\n\tmodel: any;\n\tcolor?: string;\n\tname: string;\n}\n\nnamespace S {\n\texport const Tray = styled.div<{ color: string }>`\n\t\tcolor: white;\n\t\tfont-family: Helvetica, Arial;\n\t\tpadding: 5px;\n\t\tmargin: 0px 10px;\n\t\tborder: solid 1px ${p => p.color};\n\t\tborder-radius: 5px;\n\t\tmargin-bottom: 2px;\n\t\tcursor: pointer;\n\t`;\n}\n\nexport class TrayItemWidget extends React.Component<TrayItemWidgetProps> {\n\trender() {\n\t\treturn (\n\t\t\t<S.Tray\n\t\t\t\tcolor={this.props.color}\n\t\t\t\tdraggable={true}\n\t\t\t\tonDragStart={event => {\n\t\t\t\t\tevent.dataTransfer.setData('storm-diagram-node', JSON.stringify(this.props.model));\n\t\t\t\t}}\n\t\t\t\tclassName=\"tray-item\">\n\t\t\t\t{this.props.name}\n\t\t\t</S.Tray>\n\t\t);\n\t}\n}\n","import * as React from 'react';\nimport { DiamondNodeModel } from './DiamondNodeModel';\nimport { DiagramEngine, PortModelAlignment, PortWidget } from '@projectstorm/react-diagrams';\nimport styled from '@emotion/styled';\n\nexport interface DiamonNodeWidgetProps {\n\tnode: DiamondNodeModel;\n\tengine: DiagramEngine;\n\tsize?: number;\n}\n\nnamespace S {\n\texport const Port = styled.div`\n\t\twidth: 16px;\n\t\theight: 16px;\n\t\tz-index: 10;\n\t\tbackground: rgba(0, 0, 0, 0.5);\n\t\tborder-radius: 8px;\n\t\tcursor: pointer;\n\n\t\t&:hover {\n\t\t\tbackground: rgba(0, 0, 0, 1);\n\t\t}\n\t`;\n}\n\n/**\n * @author Dylan Vorster\n */\nexport class DiamonNodeWidget extends React.Component<DiamonNodeWidgetProps> {\n\trender() {\n\t\treturn (\n\t\t\t<div\n\t\t\t\tclassName={'diamond-node'}\n\t\t\t\tstyle={{\n\t\t\t\t\tposition: 'relative',\n\t\t\t\t\twidth: this.props.size,\n\t\t\t\t\theight: this.props.size\n\t\t\t\t}}>\n\t\t\t\t<svg\n\t\t\t\t\twidth={this.props.size}\n\t\t\t\t\theight={this.props.size}\n\t\t\t\t\tdangerouslySetInnerHTML={{\n\t\t\t\t\t\t__html:\n\t\t\t\t\t\t\t`\n          <g id=\"Layer_1\">\n          </g>\n          <g id=\"Layer_2\">\n            <polygon fill=\"mediumpurple\" stroke=\"${\n\t\t\t\t\t\t\tthis.props.node.isSelected() ? 'white' : '#000000'\n\t\t\t\t\t\t}\" stroke-width=\"3\" stroke-miterlimit=\"10\" points=\"10,` +\n\t\t\t\t\t\t\tthis.props.size / 2 +\n\t\t\t\t\t\t\t` ` +\n\t\t\t\t\t\t\tthis.props.size / 2 +\n\t\t\t\t\t\t\t`,10 ` +\n\t\t\t\t\t\t\t(this.props.size - 10) +\n\t\t\t\t\t\t\t`,` +\n\t\t\t\t\t\t\tthis.props.size / 2 +\n\t\t\t\t\t\t\t` ` +\n\t\t\t\t\t\t\tthis.props.size / 2 +\n\t\t\t\t\t\t\t`,` +\n\t\t\t\t\t\t\t(this.props.size - 10) +\n\t\t\t\t\t\t\t` \"/>\n          </g>\n        `\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t\t<PortWidget\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\ttop: this.props.size / 2 - 8,\n\t\t\t\t\t\tleft: -8,\n\t\t\t\t\t\tposition: 'absolute'\n\t\t\t\t\t}}\n\t\t\t\t\tport={this.props.node.getPort(PortModelAlignment.LEFT)}\n\t\t\t\t\tengine={this.props.engine}>\n\t\t\t\t\t<S.Port />\n\t\t\t\t</PortWidget>\n\t\t\t\t<PortWidget\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tleft: this.props.size / 2 - 8,\n\t\t\t\t\t\ttop: -8,\n\t\t\t\t\t\tposition: 'absolute'\n\t\t\t\t\t}}\n\t\t\t\t\tport={this.props.node.getPort(PortModelAlignment.TOP)}\n\t\t\t\t\tengine={this.props.engine}>\n\t\t\t\t\t<S.Port />\n\t\t\t\t</PortWidget>\n\t\t\t\t<PortWidget\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tleft: this.props.size - 8,\n\t\t\t\t\t\ttop: this.props.size / 2 - 8,\n\t\t\t\t\t\tposition: 'absolute'\n\t\t\t\t\t}}\n\t\t\t\t\tport={this.props.node.getPort(PortModelAlignment.RIGHT)}\n\t\t\t\t\tengine={this.props.engine}>\n\t\t\t\t\t<S.Port />\n\t\t\t\t</PortWidget>\n\t\t\t\t<PortWidget\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tleft: this.props.size / 2 - 8,\n\t\t\t\t\t\ttop: this.props.size - 8,\n\t\t\t\t\t\tposition: 'absolute'\n\t\t\t\t\t}}\n\t\t\t\t\tport={this.props.node.getPort(PortModelAlignment.BOTTOM)}\n\t\t\t\t\tengine={this.props.engine}>\n\t\t\t\t\t<S.Port />\n\t\t\t\t</PortWidget>\n\t\t\t</div>\n\t\t);\n\t}\n}\n","import * as React from 'react';\nimport styled from '@emotion/styled';\n\nexport interface DemoCanvasWidgetProps {\n\tcolor?: string;\n\tbackground?: string;\n}\n\nnamespace S {\n\texport const Container = styled.div<{ color: string; background: string }>`\n\t\theight: 100%;\n\t\tbackground-color: rgb(60, 60, 60) !important;\n\t\tbackground-size: 50px 50px;\n\t\tdisplay: flex;\n\n\t\t> * {\n\t\t\theight: 100%;\n\t\t\tmin-height: 100%;\n\t\t\twidth: 100%;\n\t\t}\n\t\tbackground-image: linear-gradient(\n\t\t\t\t0deg,\n\t\t\t\ttransparent 24%,\n\t\t\t\t${p => p.color} 25%,\n\t\t\t\t${p => p.color} 26%,\n\t\t\t\ttransparent 27%,\n\t\t\t\ttransparent 74%,\n\t\t\t\t${p => p.color} 75%,\n\t\t\t\t${p => p.color} 76%,\n\t\t\t\ttransparent 77%,\n\t\t\t\ttransparent\n\t\t\t),\n\t\t\tlinear-gradient(\n\t\t\t\t90deg,\n\t\t\t\ttransparent 24%,\n\t\t\t\t${p => p.color} 25%,\n\t\t\t\t${p => p.color} 26%,\n\t\t\t\ttransparent 27%,\n\t\t\t\ttransparent 74%,\n\t\t\t\t${p => p.color} 75%,\n\t\t\t\t${p => p.color} 76%,\n\t\t\t\ttransparent 77%,\n\t\t\t\ttransparent\n\t\t\t);\n\t`;\n}\n\nexport class DemoCanvasWidget extends React.Component<DemoCanvasWidgetProps> {\n\trender() {\n\t\treturn (\n\t\t\t<S.Container\n\t\t\t\tbackground={this.props.background || 'rgb(60, 60, 60)'}\n\t\t\t\tcolor={this.props.color || 'rgba(255,255,255, 0.05)'}>\n\t\t\t\t{this.props.children}\n\t\t\t</S.Container>\n\t\t);\n\t}\n}\n","import * as React from 'react';\nimport styled from '@emotion/styled';\nimport { css } from '@emotion/core';\nimport { CSSProperties } from 'react';\nimport { LayerModel } from './LayerModel';\n\nexport interface TransformLayerWidgetProps {\n\tlayer: LayerModel;\n}\n\nnamespace S {\n\tconst shared = css`\n\t\ttop: 0;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tbottom: 0;\n\t\tposition: absolute;\n\t\tpointer-events: none;\n\t\ttransform-origin: 0 0;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\toverflow: visible;\n\t`;\n\n\texport const DivLayer = styled.div`\n\t\t${shared}\n\t`;\n\n\texport const SvgLayer = styled.svg`\n\t\t${shared}\n\t`;\n}\n\nexport class TransformLayerWidget extends React.Component<TransformLayerWidgetProps> {\n\tconstructor(props: TransformLayerWidgetProps) {\n\t\tsuper(props);\n\t\tthis.state = {};\n\t}\n\n\tgetTransform() {\n\t\tconst model = this.props.layer.getParent();\n\t\treturn `\n\t\t\ttranslate(\n\t\t\t\t${model.getOffsetX()}px,\n\t\t\t\t${model.getOffsetY()}px)\n\t\t\tscale(\n\t\t\t\t${model.getZoomLevel() / 100.0}\n\t\t\t)\n  \t`;\n\t}\n\n\tgetTransformStyle(): CSSProperties {\n\t\tif (this.props.layer.getOptions().transformed) {\n\t\t\treturn {\n\t\t\t\ttransform: this.getTransform()\n\t\t\t};\n\t\t}\n\t\treturn {};\n\t}\n\n\trender() {\n\t\tif (this.props.layer.getOptions().isSvg) {\n\t\t\treturn <S.SvgLayer style={this.getTransformStyle()}>{this.props.children}</S.SvgLayer>;\n\t\t}\n\t\treturn <S.DivLayer style={this.getTransformStyle()}>{this.props.children}</S.DivLayer>;\n\t}\n}\n","import * as React from 'react';\nimport styled from '@emotion/styled';\n\nexport interface SelectionBoxWidgetProps {\n\trect: ClientRect;\n}\n\nnamespace S {\n\texport const Container = styled.div`\n\t\tposition: absolute;\n\t\tbackground-color: rgba(0, 192, 255, 0.2);\n\t\tborder: solid 2px rgb(0, 192, 255);\n\t`;\n}\n\nexport class SelectionBoxWidget extends React.Component<SelectionBoxWidgetProps> {\n\trender() {\n\t\tconst { rect } = this.props;\n\t\treturn (\n\t\t\t<S.Container\n\t\t\t\tstyle={{\n\t\t\t\t\ttop: rect.top,\n\t\t\t\t\tleft: rect.left,\n\t\t\t\t\twidth: rect.width,\n\t\t\t\t\theight: rect.height\n\t\t\t\t}}\n\t\t\t/>\n\t\t);\n\t}\n}\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { DiagramEngine } from '../../DiagramEngine';\nimport { NodeModel } from './NodeModel';\nimport { BaseEntityEvent, BaseModel, ListenerHandle, PeformanceWidget } from '@projectstorm/react-canvas-core';\nimport styled from '@emotion/styled';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nexport interface NodeProps {\n\tnode: NodeModel;\n\tchildren?: any;\n\tdiagramEngine: DiagramEngine;\n}\n\nnamespace S {\n\texport const Node = styled.div`\n\t\tposition: absolute;\n\t\t-webkit-touch-callout: none; /* iOS Safari */\n\t\t-webkit-user-select: none; /* Chrome/Safari/Opera */\n\t\tuser-select: none;\n\t\tcursor: move;\n\t\tpointer-events: all;\n\t`;\n}\n\nexport class NodeWidget extends React.Component<NodeProps> {\n\tob: any;\n\tref: React.RefObject<HTMLDivElement>;\n\tlistener: ListenerHandle;\n\n\tconstructor(props: NodeProps) {\n\t\tsuper(props);\n\t\tthis.ref = React.createRef();\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.ob.disconnect();\n\t\tthis.ob = null;\n\t}\n\n\tcomponentDidUpdate(prevProps: Readonly<NodeProps>, prevState: Readonly<any>, snapshot?: any): void {\n\t\tif (this.listener && this.props.node !== prevProps.node) {\n\t\t\tthis.listener.deregister();\n\t\t\tthis.installSelectionListener();\n\t\t}\n\t}\n\n\tinstallSelectionListener() {\n\t\tthis.listener = this.props.node.registerListener({\n\t\t\tselectionChanged: (event: BaseEntityEvent<BaseModel> & { isSelected: boolean }) => {\n\t\t\t\tthis.forceUpdate();\n\t\t\t}\n\t\t});\n\t}\n\n\tcomponentDidMount(): void {\n\t\t// @ts-ignore\n\t\tthis.ob = new ResizeObserver(entities => {\n\t\t\tconst bounds = entities[0].contentRect;\n\t\t\tthis.props.node.updateDimensions({ width: bounds.width, height: bounds.height });\n\n\t\t\t//now mark the links as dirty\n\t\t\t_.forEach(this.props.node.getPorts(), port => {\n\t\t\t\tport.updateCoords(this.props.diagramEngine.getPortCoords(port));\n\t\t\t});\n\t\t});\n\t\tthis.ob.observe(this.ref.current);\n\t\tthis.installSelectionListener();\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<PeformanceWidget model={this.props.node} serialized={this.props.node.serialize()}>\n\t\t\t\t{() => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<S.Node\n\t\t\t\t\t\t\tclassName=\"node\"\n\t\t\t\t\t\t\tref={this.ref}\n\t\t\t\t\t\t\tdata-nodeid={this.props.node.getID()}\n\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\ttop: this.props.node.getY(),\n\t\t\t\t\t\t\t\tleft: this.props.node.getX()\n\t\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t{this.props.diagramEngine.generateWidgetForNode(this.props.node)}\n\t\t\t\t\t\t</S.Node>\n\t\t\t\t\t);\n\t\t\t\t}}\n\t\t\t</PeformanceWidget>\n\t\t);\n\t}\n}\n","import * as React from 'react';\nimport { DefaultLabelModel } from './DefaultLabelModel';\nimport styled from '@emotion/styled';\n\nexport interface DefaultLabelWidgetProps {\n\tmodel: DefaultLabelModel;\n}\n\nnamespace S {\n\texport const Label = styled.div`\n\t\tbackground: rgba(0, 0, 0, 0.8);\n\t\tborder-radius: 5px;\n\t\tcolor: white;\n\t\tfont-size: 12px;\n\t\tpadding: 4px 8px;\n\t\tfont-family: sans-serif;\n\t\tuser-select: none;\n\t`;\n}\n\nexport class DefaultLabelWidget extends React.Component<DefaultLabelWidgetProps> {\n\trender() {\n\t\treturn <S.Label>{this.props.model.getOptions().label}</S.Label>;\n\t}\n}\n","import * as React from 'react';\nimport { PointModel } from '@projectstorm/react-diagrams-core';\nimport styled from '@emotion/styled';\n\nexport interface DefaultLinkPointWidgetProps {\n\tpoint: PointModel;\n\tcolor?: string;\n\tcolorSelected: string;\n}\n\nexport interface DefaultLinkPointWidgetState {\n\tselected: boolean;\n}\n\nnamespace S {\n\texport const PointTop = styled.circle`\n\t\tpointer-events: all;\n\t`;\n}\n\nexport class DefaultLinkPointWidget extends React.Component<DefaultLinkPointWidgetProps, DefaultLinkPointWidgetState> {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tselected: false\n\t\t};\n\t}\n\n\trender() {\n\t\tconst { point } = this.props;\n\t\treturn (\n\t\t\t<g>\n\t\t\t\t<circle\n\t\t\t\t\tcx={point.getPosition().x}\n\t\t\t\t\tcy={point.getPosition().y}\n\t\t\t\t\tr={5}\n\t\t\t\t\tfill={this.state.selected || this.props.point.isSelected() ? this.props.colorSelected : this.props.color}\n\t\t\t\t/>\n\t\t\t\t<S.PointTop\n\t\t\t\t\tclassName=\"point\"\n\t\t\t\t\tonMouseLeave={() => {\n\t\t\t\t\t\tthis.setState({ selected: false });\n\t\t\t\t\t}}\n\t\t\t\t\tonMouseEnter={() => {\n\t\t\t\t\t\tthis.setState({ selected: true });\n\t\t\t\t\t}}\n\t\t\t\t\tdata-id={point.getID()}\n\t\t\t\t\tdata-linkid={point.getLink().getID()}\n\t\t\t\t\tcx={point.getPosition().x}\n\t\t\t\t\tcy={point.getPosition().y}\n\t\t\t\t\tr={15}\n\t\t\t\t\topacity={0.0}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t);\n\t}\n}\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { DefaultNodeModel } from './DefaultNodeModel';\nimport { DefaultPortLabel } from '../port/DefaultPortLabelWidget';\nimport styled from '@emotion/styled';\nimport { ContextMenu, ContextMenuTrigger } from 'react-contextmenu';\nimport { NodeContextMenu } from './NodeContextMenu';\nimport { NodeAttributes } from './NodeAttributes';\n\nnamespace S {\n\texport const Node = styled.div<{ background: string; selected: boolean }>`\n\t\tbackground-color: ${p => p.background};\n\t\tborder-radius: 5px;\n\t\tfont-family: sans-serif;\n\t\tcolor: white;\n\t\tborder: solid 2px black;\n\t\toverflow: visible;\n\t\tfont-size: 11px;\n\t\tborder: solid 2px ${p => (p.selected ? 'rgb(0,192,255)' : 'black')};\n\t`;\n\n\texport const Title = styled.div`\n\t\tbackground: rgba(0, 0, 0, 0.3);\n\t\tdisplay: flex;\n\t\twhite-space: nowrap;\n\t\tjustify-items: center;\n\t`;\n\n\texport const TitleName = styled.div`\n\t\tflex-grow: 1;\n\t\tpadding: 5px 5px;\n\t`;\n\n\texport const Ports = styled.div`\n\t\tdisplay: flex;\n\t\tbackground-image: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2));\n\t`;\n\n\texport const PortsContainer = styled.div`\n\t\tflex-grow: 1;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\n\t\t&:first-of-type {\n\t\t\tmargin-right: 10px;\n\t\t}\n\n\t\t&:only-child {\n\t\t\tmargin-right: 0px;\n\t\t}\n\t`;\n}\n\nexport interface DefaultNodeProps {\n\tnode: DefaultNodeModel;\n\tengine: DiagramEngine;\n}\n\n/**\n * Default node that models the DefaultNodeModel. It creates two columns\n * for both all the input ports on the left, and the output ports on the right.\n */\nexport class DefaultNodeWidget extends React.Component<DefaultNodeProps> {\n\tgeneratePort = port => {\n\t\treturn <DefaultPortLabel engine={this.props.engine} port={port} key={port.getID()} />;\n\t};\n\n\trender() {\n\t\tconst { node } = this.props;\n\n\t\treturn (\n\t\t\t<S.Node\n\t\t\t\tkey={node.getOptions().id}\n\t\t\t\tdata-default-node-name={node.getOptions().name}\n\t\t\t\tselected={this.props.node.isSelected()}\n\t\t\t\tbackground={this.props.node.getOptions().color}>\n\t\t\t\t<S.Title>\n\t\t\t\t\t<S.TitleName>{node.getOptions().name}</S.TitleName>\n\t\t\t\t</S.Title>\n\t\t\t\t<ContextMenuTrigger id={node.getOptions().id}>\n\t\t\t\t\t<NodeAttributes node={node} />\n\t\t\t\t</ContextMenuTrigger>\n\t\t\t\t<ContextMenu id={node.getOptions().id}>\n\t\t\t\t\t<NodeContextMenu node={node}></NodeContextMenu>\n\t\t\t\t</ContextMenu>\n\t\t\t\t<S.Ports>\n\t\t\t\t\t<S.PortsContainer>{_.map(node.getInPorts(), this.generatePort)}</S.PortsContainer>\n\t\t\t\t\t<S.PortsContainer>{_.map(node.getOutPorts(), this.generatePort)}</S.PortsContainer>\n\t\t\t\t</S.Ports>\n\t\t\t</S.Node>\n\t\t);\n\t}\n}\n","import * as React from 'react';\nimport { DiagramEngine, PortWidget } from '@projectstorm/react-diagrams-core';\nimport { DefaultPortModel } from './DefaultPortModel';\nimport styled from '@emotion/styled';\n\nexport interface DefaultPortLabelProps {\n\tport: DefaultPortModel;\n\tengine: DiagramEngine;\n}\n\nnamespace S {\n\texport const PortLabel = styled.div`\n\t\tdisplay: flex;\n\t\tmargin-top: 1px;\n\t\talign-items: center;\n\t`;\n\n\texport const Label = styled.div`\n\t\tpadding: 0 5px;\n\t\tflex-grow: 1;\n\t`;\n\n\texport const Port = styled.div`\n\t\twidth: 15px;\n\t\theight: 15px;\n\t\tbackground: rgba(white, 0.1);\n\n\t\t&:hover {\n\t\t\tbackground: rgb(192, 255, 0);\n\t\t}\n\t`;\n}\n\nexport class DefaultPortLabel extends React.Component<DefaultPortLabelProps> {\n\trender() {\n\t\tconst port = (\n\t\t\t<PortWidget engine={this.props.engine} port={this.props.port}>\n\t\t\t\t<S.Port />\n\t\t\t</PortWidget>\n\t\t);\n\t\tconst label = <S.Label>{this.props.port.getOptions().label}</S.Label>;\n\n\t\treturn (\n\t\t\t<S.PortLabel>\n\t\t\t\t{this.props.port.getOptions().in ? port : label}\n\t\t\t\t{this.props.port.getOptions().in ? label : port}\n\t\t\t</S.PortLabel>\n\t\t);\n\t}\n}\n","import { DefaultNodeModel } from './DefaultNodeModel';\nimport * as React from 'react';\nimport styled from '@emotion/styled';\n\nnamespace S {\n\texport const Attributes = styled.div`\n\t\tdisplay: flex;\n\t\tpadding: 1rem 2rem;\n\t\tflex-direction: column;\n\t\twhite-space: nowrap;\n\t\tjustify-items: center;\n\t`;\n}\n\nexport interface NodeAttributesProps {\n\tnode: DefaultNodeModel;\n}\n\nexport const NodeAttributes = (props: NodeAttributesProps) => {\n\tconst { node } = props;\n\n\tconst attributes = node.getOptions().attributes;\n\n\treturn (\n\t\t<S.Attributes>\n\t\t\t{attributes.length !== 0 &&\n\t\t\t\tattributes.map(attr => Object.keys(attr).map(key => <div key={key}>{`${key}: ${attr[key]}`}</div>))}\n\t\t</S.Attributes>\n\t);\n};\n","import * as React from 'react';\nimport styled from '@emotion/styled';\n\nexport interface DemoWorkspaceWidgetProps {\n\tbuttons?: any;\n}\n\nnamespace S {\n\texport const Toolbar = styled.div`\n\t\tpadding: 5px;\n\t\tdisplay: flex;\n\t\tflex-shrink: 0;\n\t`;\n\n\texport const Content = styled.div`\n\t\tflex-grow: 1;\n\t\theight: 100%;\n\t`;\n\n\texport const Container = styled.div`\n\t\tbackground: black;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\theight: 100%;\n\t\tborder-radius: 5px;\n\t\toverflow: hidden;\n\t`;\n}\n\nexport const DemoButton = styled.button`\n\tbackground: rgb(60, 60, 60);\n\tfont-size: 14px;\n\tpadding: 5px 10px;\n\tborder: none;\n\tcolor: white;\n\toutline: none;\n\tcursor: pointer;\n\tmargin: 2px;\n\tborder-radius: 3px;\n\n\t&:hover {\n\t\tbackground: rgb(0, 192, 255);\n\t}\n`;\n\nexport class DemoWorkspaceWidget extends React.Component<DemoWorkspaceWidgetProps> {\n\trender() {\n\t\treturn (\n\t\t\t<S.Container>\n\t\t\t\t<S.Toolbar>{this.props.buttons}</S.Toolbar>\n\t\t\t\t<S.Content>{this.props.children}</S.Content>\n\t\t\t</S.Container>\n\t\t);\n\t}\n}\n","import * as React from 'react';\nimport { CanvasEngine } from '../../CanvasEngine';\nimport { TransformLayerWidget } from '../layer/TransformLayerWidget';\nimport styled from '@emotion/styled';\nimport { SmartLayerWidget } from '../layer/SmartLayerWidget';\n\nexport interface DiagramProps {\n\tengine: CanvasEngine;\n\tclassName?: string;\n}\n\nnamespace S {\n\texport const Canvas = styled.div`\n\t\tposition: relative;\n\t\tcursor: move;\n\t\toverflow: hidden;\n\t`;\n}\n\nexport class CanvasWidget extends React.Component<DiagramProps> {\n\tref: React.RefObject<HTMLDivElement>;\n\tkeyUp: any;\n\tkeyDown: any;\n\tcanvasListener: any;\n\n\tconstructor(props: DiagramProps) {\n\t\tsuper(props);\n\n\t\tthis.ref = React.createRef();\n\t\tthis.state = {\n\t\t\taction: null,\n\t\t\tdiagramEngineListener: null\n\t\t};\n\t}\n\n\tcomponentWillUnmount() {\n\t\tthis.props.engine.deregisterListener(this.canvasListener);\n\t\tthis.props.engine.setCanvas(null);\n\n\t\tdocument.removeEventListener('keyup', this.keyUp);\n\t\tdocument.removeEventListener('keydown', this.keyDown);\n\t}\n\n\tregisterCanvas() {\n\t\tthis.props.engine.setCanvas(this.ref.current);\n\t\tthis.props.engine.iterateListeners(list => {\n\t\t\tlist.rendered && list.rendered();\n\t\t});\n\t}\n\n\tcomponentDidUpdate() {\n\t\tthis.registerCanvas();\n\t}\n\n\tcomponentDidMount() {\n\t\tthis.canvasListener = this.props.engine.registerListener({\n\t\t\trepaintCanvas: () => {\n\t\t\t\tthis.forceUpdate();\n\t\t\t}\n\t\t});\n\n\t\tthis.keyDown = event => {\n\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\n\t\t};\n\t\tthis.keyUp = event => {\n\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\n\t\t};\n\n\t\tdocument.addEventListener('keyup', this.keyUp);\n\t\tdocument.addEventListener('keydown', this.keyDown);\n\t\tthis.registerCanvas();\n\t}\n\n\trender() {\n\t\tconst engine = this.props.engine;\n\t\tconst model = engine.getModel();\n\n\t\treturn (\n\t\t\t<S.Canvas\n\t\t\t\tclassName={this.props.className}\n\t\t\t\tref={this.ref}\n\t\t\t\tonWheel={event => {\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\n\t\t\t\t}}\n\t\t\t\tonMouseDown={event => {\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\n\t\t\t\t}}\n\t\t\t\tonMouseUp={event => {\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\n\t\t\t\t}}\n\t\t\t\tonMouseMove={event => {\n\t\t\t\t\tthis.props.engine.getActionEventBus().fireAction({ event });\n\t\t\t\t}}>\n\t\t\t\t{model.getLayers().map(layer => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<TransformLayerWidget layer={layer} key={layer.getID()}>\n\t\t\t\t\t\t\t<SmartLayerWidget layer={layer} engine={this.props.engine} key={layer.getID()} />\n\t\t\t\t\t\t</TransformLayerWidget>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</S.Canvas>\n\t\t);\n\t}\n}\n","import * as React from 'react';\nimport { DiagramEngine } from '../../DiagramEngine';\nimport { LabelModel } from './LabelModel';\nimport styled from '@emotion/styled';\n\nexport interface LabelWidgetProps {\n\tengine: DiagramEngine;\n\tlabel: LabelModel;\n\tindex: number;\n}\n\nnamespace S {\n\texport const Label = styled.div`\n\t\tdisplay: inline-block;\n\t\tposition: absolute;\n\t`;\n\n\texport const Foreign = styled.foreignObject`\n\t\tpointer-events: none;\n\t\toverflow: visible;\n\t`;\n}\n\nexport class LabelWidget extends React.Component<LabelWidgetProps> {\n\tref: React.RefObject<HTMLDivElement>;\n\n\tconstructor(props: LabelWidgetProps) {\n\t\tsuper(props);\n\t\tthis.ref = React.createRef();\n\t}\n\n\tcomponentDidUpdate() {\n\t\twindow.requestAnimationFrame(this.calculateLabelPosition);\n\t}\n\n\tcomponentDidMount() {\n\t\twindow.requestAnimationFrame(this.calculateLabelPosition);\n\t}\n\n\tfindPathAndRelativePositionToRenderLabel = (index: number): { path: SVGPathElement; position: number } => {\n\t\t// an array to hold all path lengths, making sure we hit the DOM only once to fetch this information\n\t\tconst link = this.props.label.getParent();\n\t\tconst lengths = link.getRenderedPath().map(path => path.getTotalLength());\n\n\t\t// calculate the point where we want to display the label\n\t\tlet labelPosition =\n\t\t\tlengths.reduce((previousValue, currentValue) => previousValue + currentValue, 0) *\n\t\t\t(index / (link.getLabels().length + 1));\n\n\t\t// find the path where the label will be rendered and calculate the relative position\n\t\tlet pathIndex = 0;\n\t\twhile (pathIndex < link.getRenderedPath().length) {\n\t\t\tif (labelPosition - lengths[pathIndex] < 0) {\n\t\t\t\treturn {\n\t\t\t\t\tpath: link.getRenderedPath()[pathIndex],\n\t\t\t\t\tposition: labelPosition\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// keep searching\n\t\t\tlabelPosition -= lengths[pathIndex];\n\t\t\tpathIndex++;\n\t\t}\n\t};\n\n\tcalculateLabelPosition = () => {\n\t\tconst found = this.findPathAndRelativePositionToRenderLabel(this.props.index + 1);\n\t\tif (!found) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { path, position } = found;\n\n\t\tconst labelDimensions = {\n\t\t\twidth: this.ref.current.offsetWidth,\n\t\t\theight: this.ref.current.offsetHeight\n\t\t};\n\n\t\tconst pathCentre = path.getPointAtLength(position);\n\n\t\tconst labelCoordinates = {\n\t\t\tx: pathCentre.x - labelDimensions.width / 2 + this.props.label.getOptions().offsetX,\n\t\t\ty: pathCentre.y - labelDimensions.height / 2 + this.props.label.getOptions().offsetY\n\t\t};\n\n\t\tthis.ref.current.style.transform = `translate(${labelCoordinates.x}px, ${labelCoordinates.y}px)`;\n\t};\n\n\trender() {\n\t\tconst canvas = this.props.engine.getCanvas();\n\t\treturn (\n\t\t\t<S.Foreign key={this.props.label.getID()} width={canvas.offsetWidth} height={canvas.offsetHeight}>\n\t\t\t\t<S.Label ref={this.ref}>\n\t\t\t\t\t{this.props.engine.getFactoryForLabel(this.props.label).generateReactWidget({ model: this.props.label })}\n\t\t\t\t</S.Label>\n\t\t\t</S.Foreign>\n\t\t);\n\t}\n}\n","import { NodeModel } from './entities/node/NodeModel';\nimport { PortModel } from './entities/port/PortModel';\nimport { LinkModel } from './entities/link/LinkModel';\nimport { LabelModel } from './entities/label/LabelModel';\nimport { Point, Rectangle } from '@projectstorm/geometry';\nimport { MouseEvent } from 'react';\nimport {\n\tAbstractModelFactory,\n\tAbstractReactFactory,\n\tBaseModel,\n\tCanvasEngine,\n\tFactoryBank,\n\tToolkit\n} from '@projectstorm/react-canvas-core';\nimport { CanvasEngineListener, CanvasEngineOptions } from '@projectstorm/react-canvas-core';\nimport { DiagramModel } from './models/DiagramModel';\n\n/**\n * Passed as a parameter to the DiagramWidget\n */\nexport class DiagramEngine extends CanvasEngine<CanvasEngineListener, DiagramModel> {\n\tprotected nodeFactories: FactoryBank<AbstractReactFactory<NodeModel, DiagramEngine>>;\n\tprotected linkFactories: FactoryBank<AbstractReactFactory<LinkModel, DiagramEngine>>;\n\tprotected portFactories: FactoryBank<AbstractModelFactory<PortModel, DiagramEngine>>;\n\tprotected labelFactories: FactoryBank<AbstractReactFactory<LabelModel, DiagramEngine>>;\n\n\tmaxNumberPointsPerLink: number;\n\n\tconstructor(options: CanvasEngineOptions = {}) {\n\t\tsuper(options);\n\t\tthis.maxNumberPointsPerLink = 1000;\n\n\t\t// create banks for the different factory types\n\t\tthis.nodeFactories = new FactoryBank();\n\t\tthis.linkFactories = new FactoryBank();\n\t\tthis.portFactories = new FactoryBank();\n\t\tthis.labelFactories = new FactoryBank();\n\n\t\tconst setup = (factory: FactoryBank) => {\n\t\t\tfactory.registerListener({\n\t\t\t\tfactoryAdded: event => {\n\t\t\t\t\tevent.factory.setDiagramEngine(this);\n\t\t\t\t},\n\t\t\t\tfactoryRemoved: event => {\n\t\t\t\t\tevent.factory.setDiagramEngine(null);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tsetup(this.nodeFactories);\n\t\tsetup(this.linkFactories);\n\t\tsetup(this.portFactories);\n\t\tsetup(this.labelFactories);\n\t}\n\n\t/**\n\t * Gets a model and element under the mouse cursor\n\t */\n\tgetMouseElement(event: MouseEvent): BaseModel {\n\t\tvar target = event.target as Element;\n\t\tvar diagramModel = this.model;\n\n\t\t//is it a port\n\t\tvar element = Toolkit.closest(target, '.port[data-name]');\n\t\tif (element) {\n\t\t\tvar nodeElement = Toolkit.closest(target, '.node[data-nodeid]') as HTMLElement;\n\t\t\treturn diagramModel.getNode(nodeElement.getAttribute('data-nodeid')).getPort(element.getAttribute('data-name'));\n\t\t}\n\n\t\t//look for a point\n\t\telement = Toolkit.closest(target, '.point[data-id]');\n\t\tif (element) {\n\t\t\treturn diagramModel.getLink(element.getAttribute('data-linkid')).getPointModel(element.getAttribute('data-id'));\n\t\t}\n\n\t\t//look for a link\n\t\telement = Toolkit.closest(target, '[data-linkid]');\n\t\tif (element) {\n\t\t\treturn diagramModel.getLink(element.getAttribute('data-linkid'));\n\t\t}\n\n\t\t//look for a node\n\t\telement = Toolkit.closest(target, '.node[data-nodeid]');\n\t\tif (element) {\n\t\t\treturn diagramModel.getNode(element.getAttribute('data-nodeid'));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t//!-------------- FACTORIES ------------\n\n\tgetNodeFactories() {\n\t\treturn this.nodeFactories;\n\t}\n\n\tgetLinkFactories() {\n\t\treturn this.linkFactories;\n\t}\n\n\tgetLabelFactories() {\n\t\treturn this.labelFactories;\n\t}\n\n\tgetPortFactories() {\n\t\treturn this.portFactories;\n\t}\n\n\tgetFactoryForNode<F extends AbstractReactFactory<NodeModel, DiagramEngine>>(node: NodeModel | string) {\n\t\tif (typeof node === 'string') {\n\t\t\treturn this.nodeFactories.getFactory(node);\n\t\t}\n\t\treturn this.nodeFactories.getFactory(node.getType());\n\t}\n\n\tgetFactoryForLink<F extends AbstractReactFactory<LinkModel, DiagramEngine>>(link: LinkModel | string) {\n\t\tif (typeof link === 'string') {\n\t\t\treturn this.linkFactories.getFactory<F>(link);\n\t\t}\n\t\treturn this.linkFactories.getFactory<F>(link.getType());\n\t}\n\n\tgetFactoryForLabel<F extends AbstractReactFactory<LabelModel, DiagramEngine>>(label: LabelModel) {\n\t\tif (typeof label === 'string') {\n\t\t\treturn this.labelFactories.getFactory(label);\n\t\t}\n\t\treturn this.labelFactories.getFactory(label.getType());\n\t}\n\n\tgetFactoryForPort<F extends AbstractModelFactory<PortModel, DiagramEngine>>(port: PortModel) {\n\t\tif (typeof port === 'string') {\n\t\t\treturn this.portFactories.getFactory<F>(port);\n\t\t}\n\t\treturn this.portFactories.getFactory<F>(port.getType());\n\t}\n\n\tgenerateWidgetForLink(link: LinkModel): JSX.Element {\n\t\treturn this.getFactoryForLink(link).generateReactWidget({ model: link });\n\t}\n\n\tgenerateWidgetForNode(node: NodeModel): JSX.Element {\n\t\treturn this.getFactoryForNode(node).generateReactWidget({ model: node });\n\t}\n\n\tgetNodeElement(node: NodeModel): Element {\n\t\tconst selector = this.canvas.querySelector(`.node[data-nodeid=\"${node.getID()}\"]`);\n\t\tif (selector === null) {\n\t\t\tthrow new Error('Cannot find Node element with nodeID: [' + node.getID() + ']');\n\t\t}\n\t\treturn selector;\n\t}\n\n\tgetNodePortElement(port: PortModel): any {\n\t\tvar selector = this.canvas.querySelector(\n\t\t\t`.port[data-name=\"${port.getName()}\"][data-nodeid=\"${port.getParent().getID()}\"]`\n\t\t);\n\t\tif (selector === null) {\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot find Node Port element with nodeID: [' +\n\t\t\t\t\tport.getParent().getID() +\n\t\t\t\t\t'] and name: [' +\n\t\t\t\t\tport.getName() +\n\t\t\t\t\t']'\n\t\t\t);\n\t\t}\n\t\treturn selector;\n\t}\n\n\tgetPortCenter(port: PortModel): Point {\n\t\treturn this.getPortCoords(port).getOrigin();\n\t}\n\n\t/**\n\t * Calculate rectangular coordinates of the port passed in.\n\t */\n\tgetPortCoords(port: PortModel, element?: HTMLDivElement): Rectangle {\n\t\tif (!this.canvas) {\n\t\t\tthrow new Error('Canvas needs to be set first');\n\t\t}\n\t\tif (!element) {\n\t\t\telement = this.getNodePortElement(port);\n\t\t}\n\t\tconst sourceRect = element.getBoundingClientRect();\n\t\tconst point = this.getRelativeMousePoint({\n\t\t\tclientX: sourceRect.left,\n\t\t\tclientY: sourceRect.top\n\t\t});\n\t\tconst zoom = this.model.getZoomLevel() / 100.0;\n\t\treturn new Rectangle(point.x, point.y, sourceRect.width / zoom, sourceRect.height / zoom);\n\t}\n\n\t/**\n\t * Determine the width and height of the node passed in.\n\t * It currently assumes nodes have a rectangular shape, can be overriden for customised shapes.\n\t */\n\tgetNodeDimensions(node: NodeModel): { width: number; height: number } {\n\t\tif (!this.canvas) {\n\t\t\treturn {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t}\n\n\t\tconst nodeElement = this.getNodeElement(node);\n\t\tconst nodeRect = nodeElement.getBoundingClientRect();\n\n\t\treturn {\n\t\t\twidth: nodeRect.width,\n\t\t\theight: nodeRect.height\n\t\t};\n\t}\n\n\tgetMaxNumberPointsPerLink(): number {\n\t\treturn this.maxNumberPointsPerLink;\n\t}\n\n\tsetMaxNumberPointsPerLink(max: number) {\n\t\tthis.maxNumberPointsPerLink = max;\n\t}\n}\n","import * as React from 'react';\nimport { DefaultLinkModel } from './DefaultLinkModel';\nimport { DefaultLinkWidget } from './DefaultLinkWidget';\nimport styled from '@emotion/styled';\nimport { css, keyframes } from '@emotion/core';\nimport { AbstractReactFactory } from '@projectstorm/react-canvas-core';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\n\nnamespace S {\n\texport const Keyframes = keyframes`\n\t\tfrom {\n\t\t\tstroke-dashoffset: 24;\n\t\t}\n\t\tto {\n\t\t\tstroke-dashoffset: 0;\n\t\t}\n\t`;\n\n\tconst selected = css`\n\t\tstroke-dasharray: 10, 2;\n\t\tanimation: ${Keyframes} 1s linear infinite;\n\t`;\n\n\texport const Path = styled.path<{ selected: boolean }>`\n\t\t${p => p.selected && selected};\n\t\tfill: none;\n\t\tpointer-events: all;\n\t`;\n}\n\nexport class DefaultLinkFactory<Link extends DefaultLinkModel = DefaultLinkModel> extends AbstractReactFactory<\n\tLink,\n\tDiagramEngine\n> {\n\tconstructor(type = 'default') {\n\t\tsuper(type);\n\t}\n\n\tgenerateReactWidget(event): JSX.Element {\n\t\treturn <DefaultLinkWidget link={event.model} diagramEngine={this.engine} />;\n\t}\n\n\tgenerateModel(event): Link {\n\t\treturn new DefaultLinkModel() as Link;\n\t}\n\n\tgenerateLinkSegment(model: Link, selected: boolean, path: string) {\n\t\treturn (\n\t\t\t<S.Path\n\t\t\t\tselected={selected}\n\t\t\t\tstroke={selected ? model.getOptions().selectedColor : model.getOptions().color}\n\t\t\t\tstrokeWidth={model.getOptions().width}\n\t\t\t\td={path}\n\t\t\t/>\n\t\t);\n\t}\n}\n","import { DefaultNodeModel } from './DefaultNodeModel';\nimport * as React from 'react';\nimport styled from '@emotion/styled';\nimport { NodeAttributes } from './NodeAttributes';\n\nnamespace S {\n\texport const ContentMenu = styled.div`\n\t\tpadding: 0.5rem;\n\t\tborder-radius: 3px;\n\t\tborder: 1px solid black;\n\t\tbackground: white;\n\t\tcolor: black;\n\t`;\n\n\texport const Attributes = styled.div`\n\t\tdisplay: flex;\n\t\tpadding: 0.2rem;\n\t\tflex-direction: column;\n\t\twhite-space: nowrap;\n\t\tjustify-items: center;\n\t`;\n\n\texport const TitleName = styled.div`\n\t\tflex-grow: 1;\n\t\tpadding: 5px 5px;\n\t\tfont-weight: bold;\n\t`;\n\n\texport const Buttons = styled.div`\n\t\tdisplay: flex;\n\t\tflex-direction: row;\n\t\tjustify-content: flex-end;\n\t`;\n}\n\nexport interface NodeContextMenuProps {\n\tnode: DefaultNodeModel;\n}\n\nexport const NodeContextMenu = (props: NodeContextMenuProps) => {\n\tconst { node } = props;\n\n\treturn (\n\t\t<S.ContentMenu>\n\t\t\t<S.TitleName>{node.getOptions().name}</S.TitleName>\n\t\t\t<hr />\n\t\t\t<NodeAttributes node={node}></NodeAttributes>\n\t\t\t<S.Buttons>\n\t\t\t\t<button>Cancel</button>\n\t\t\t\t<button>Apply</button>\n\t\t\t</S.Buttons>\n\t\t</S.ContentMenu>\n\t);\n};\n"],"mappings":"AAAA;;ACsDA;;AAJA;;ACdA;AAQA;AAHA;;;;;ACnBA;;;;;;;;;AAWA;;;AAKA;;;AAxBA;;;;;ACXA;;;;;ACYA;;;;AANA;;;;;;;;;;;ACEA;;;;;;;;;;;;;;ACYA;AACA;;;AAGA;AACA;;;;;;;AAOA;AACA;;;AAGA;AACA;;;;AAhCA;;;;;;;;;;;ACgBA;AACA;AAGA;AACA;AAnBA;;;;ACHA;;;;;;;ACOA;;;;;;;;ACNA;;ACMA;ACFA;;;;;;;AAOA;AAGA;;;;;AAOA;;;AAKA;;;AAKA;;;;;;;;;;;;AA7BA;;;;ACOA;;;AAKA;;;;;;;;AAZA;;;;;;ACNA;;;;ACUA;;;AAKA;;;;;;;AAZA;;;;;;;;;;;;;;AAsCA;;;;AClCA;;;ACMA;;;AANA;;ACiFA;;;;;;;AC1EA;;AAEA;AAGA;AACA;;;AAhBA;;;;;;ACMA;;;;;;AAQA;;;;AAMA;;;;AAvBA","sourceRoot":""}